'''
Customized tkinter widgets to generate objects based on these classes.
Carleton University
Summer of 2019
Author: Carlos Daniel Flores Pinedo
Contact: carlosdanielfp@outlook.com
'''
from tkinter import *
class ClickableCnt(Frame):
    '''
    Clickable frame which acts as a button, but can contain different widgets.
    Note: To bind functions to any instance of this or any inherited class use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,cnf={},**kw):
        '''
        Constructs a clickable frame widget with the parent master.
        The visual aspect will change depending on the events generated by the pointer just like a button.
        '''
        Frame.__init__(self,master,kw)
        self.reset()
    def on_enter(self,event):
        '''This function changes the aspect of the frame and its content when the pointer enters the area of the frame.'''
        bgColor(self,"#595959")
        fgColor(self,"white")
    def on_leave(self,event):
        '''This function changes the aspect of the frame and its content when the pointer leaves the area of the frame.'''
        bgColor(self,"#4d4d4d")
        fgColor(self,"#cccccc")
    def on_press(self,event):
        '''This function changes the aspect of the frame and its content when the mouse is clicked with the pointer over the area of the frame.'''
        self.press()
    def on_release(self,event):
        '''This function changes the aspect of the frame and its content when the mouse is clicked with the pointer over the area of the frame.'''
        self.on_enter(event)
    def reset(self):
        '''Set default aspect of the frame and bind pointer actions to their respective functions.'''
        bgColor(self,"#4d4d4d")
        fgColor(self,"#cccccc")
        multiBind(self,"<Enter>",self.on_enter)
        self.bind("<Leave>",self.on_leave) #Aspect only changes when the pointer leaves que whole frame, not individual items.
        multiBind(self,"<1>",self.on_press)
        multiBind(self,"<ButtonRelease-1>",self.on_release)
    def press(self):
        '''Aspect change for button pressed'''
        bgColor(self,"#262626")
        fgColor(self,"white")
    def lock(self):
        '''Disable button functionality by unbiding every event.'''
        multiUnbind(self,"<Enter>")
        multiUnbind(self,"<Leave>")
        multiUnbind(self,"<1>")
        multiUnbind(self,"<ButtonRelease-1>")
    def lockButPress(self):
        '''Unbind every pointer event but when pressed.'''
        multiUnbind(self,"<Enter>")
        multiUnbind(self,"<Leave>")
        multiUnbind(self,"<ButtonRelease-1>")
class MyButton(ClickableCnt):
    '''
    Button (clickable frame with a centered label). This widget acts as a regular button.
    Note: To bind functions to any instance of this or any inherited class use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,text="",cnf={},**kw):
        '''
        Constructs a labeled button with the parent master.
        The minimum width of the label is set to a char width of the longest line in the string plus 2.
        Parameter...
        text : Gets the string to show inside the button.
        '''
        ClickableCnt.__init__(self,master,kw)
        self.txtLbl=Label(self,text=text,width=self.getWidth(text))
        self.txtLbl.pack(side=LEFT,padx="2p",expand=True)
        self.txtLbl.pack_propagate(0)
        self.reset()
    def getWidth(self,text):
        '''Get the best char width for the label shown in the button taking it from the longest line in the string and adding 2.'''
        aux=""
        for i in text.split('\n'):
            if(len(i)>len(aux)):
                aux=i
        return len(aux)+2
class NavButton(ClickableCnt):
    '''
    Button (clickable frame with a centered label). This widget acts as a regular button. The aspect is more suitable for page navigation.
    Note: To bind functions to any instance of this or any inherited class use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,text="",cnf={},**kw):
        '''
        Constructs a labeled button with the parent master.
        It has special padding for navigation through the program.
        Parameter:
        text : Gets the string to show inside the button.
        '''
        ClickableCnt.__init__(self,master,kw)
        self.txtLbl=Label(self,text=text,font="bold",fg="#cccccc")
        self.txtLbl.pack(fill=BOTH,padx="10p",pady="10p")
        self.pack_configure(side=LEFT,fill=X,padx="0p",pady="10p 0p",anchor="center",expand=1)
        self.pack_propagate(1)
        self.reset()
class MyButtonOpt(MyButton):
    '''
    Button suitable for automatically generated button groups.
    Master needs to have variables (ind as int) and (var as IntVariable).
    Note: To bind functions to any instance of this or any inherited class use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,text="",packSide=LEFT,cnf={},**kw):
        '''
        Constructs a button with parent master.
        Parameters:
        text: Sets the text of the label in the button. This will later be the value sent to the master if the button is clicked.
        packSide:   [LEFT,TOP]
                    Sets the orientation in which the buttons will be packed in the master container. 
                    e.g.: packSide=LEFT would create an horizontal group of buttons.        '''
        MyButton.__init__(self,master,text,kw)
        self.pack(side=packSide,fill=BOTH,expand=1)
        self.pack_propagate(1)
        self.reset()
    def on_press(self,event):
        '''Overwrite the function from superclass MyButton to add the tracking functionality which changes the values of the master widget to recognize the button clicked.'''
        MyButton.on_press(self,event)
        self.master.ind=self.master.cnt.index(self)#Gets the index of the button clicked in the container of the list of buttons in the group and sets it.
        self.master.var.set(self.txtLbl.cget("text"))#Sets the text of the button clicked as the value of var in the master widget.
class MyButtonGroup(Frame):
    '''
    Group of buttons related to each other and generated with an iterable of strings.
    These buttons are assigned to a list contanier variable called cnt.
    It recognizes the button clicked through the variables ind and var.
    Note: To bind functions to any button generated use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,elem=("KHz","MHz","GHz","THz"),packSide=LEFT,cnf={},**kw):
        '''
        Constructs a group of buttons with parent master.
        Parameters:
        elem: Iterable of strings with which the buttons are generated.
        packSide:   [LEFT,TOP]
                    Sets the orientation in which the buttons will be packed in the master container. 
                    e.g.: packSide=LEFT would create an horizontal group of buttons.        '''
        Frame.__init__(self,master,kw)
        self.var=StringVar(self,elem[0])
        self.ind=0
        self["highlightthickness"]="1p"
        self["highlightbackground"]="#4d4d4d"
        self.cnt=[]
        for i in range(len(elem)):
            self.cnt.append(MyButtonOpt(self,text=elem[i],packSide=packSide))
class MyComboB(MyButtonGroup):
    '''
    Pick-One group of buttons that acts as a radio button group.
    As soon as one button is clicked the other buttons are reset and the pressed button stays pressed and fully locked.
    Each button sets state variables of the group to the pressed button when pressed.
    Note: To bind functions to any button generated use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,elem=None,packSide=LEFT,cnf={},**kw):
        '''
        Constructs a group of buttons with parent master.
        When created, it sets the first button as pressed by default.
        Parameters:
        elem: Iterable of strings with which the buttons are generated.
        packSide:   [LEFT,TOP]
                    Sets the orientation in which the buttons will be packed in the master container. 
                    e.g.: packSide=LEFT would create an horizontal group of buttons.        '''
        MyButtonGroup.__init__(self,master,elem,packSide,kw)
        self.select()
    def trig(self,event):
        '''Function triggered by the click of a button to make the selection of a button.'''
        self.select()
    def selectElem(self):
        '''Selection of element from var. This function gets the index of the button from currently set value of var and runs the main selection function.'''
        for i in self.cnt:
            if(self.var.get()==i.txtLbl.cget("text")):
                self.ind=self.cnt.index(i)
        self.select()
    def select(self):
        '''Selection of button clicked. Disables the button clicked and enables the rest of the buttons my going through the list cnt.'''
        for i in self.cnt:
            if (self.cnt.index(i)==self.ind):
                i.press()
                i.lock()#Unbind every event's function.
            else:
                i.reset()
                multiBind(i,"<Button-1>",self.trig,1)
class MyComboBMulti(MyButtonGroup):
    '''
    Pick-Multiple group of buttons that acts as a check button group.
    When one button is pressed it stays visualy pressed, but it can be pressed again to reset it.
    Through the list variables varLs and indLs, this wdiget keeps track of the list of pressed buttons.
    Note: To bind functions to any button generated use parameter add=True to avoid losing appearance behavior.
    '''
    def __init__(self,master,elem=None,packSide=LEFT,cnf={},**kw):
        '''
        Constructs a group of buttons with parent master.
        Parameters:
        elem: Iterable of strings with which the buttons are generated.
        packSide:   [LEFT,TOP]
                    Sets the orientation in which the buttons will be packed in the master container. 
                    e.g.: packSide=LEFT would create an horizontal group of buttons.
        '''
        MyButtonGroup.__init__(self,master,elem,packSide,kw)
        self.varLs=[]#List of string variables that keeps track of the pressed buttons and contains the text of the pressed buttons.
        self.indLs=[]#List of integer variables that keeps track of the pressed buttons and contains the index of the pressed buttons.
        self.ready=IntVar(self,0)#tkinter integer variable used to trigger a function that needs to be run after the state variables have been updated.
        self.select()#Run the initial update of variables.
        self.var.trace_add("write",self.trig)#Binding of the variable var to update the lists as soon as it is modified.
    def trig(self,a,b,c):
        '''Runs the update of the state variables and visual aspect.
        After this it sets the variable ready with a dummy value of zero to trigger any master function that needs to be ran after the update.'''
        self.select()
        self.ready.set(0)
    def select(self):
        '''Verifies if the pressed button is already pressed.
        If it is, it resets the verified button and removes the button from the state list variables.
        If it is not, it leaves the button pressed and adds the button to the state list variables.'''
        if(self.indLs.count(self.ind)):
            self.indLs.remove(self.ind)
            self.varLs.remove(self.var.get())
        else:
            self.indLs.append(self.ind)
            self.varLs.append(self.var.get())
            self.varLs.sort()
        for i in self.cnt:
            if (self.indLs.count(self.cnt.index(i))):
                i.press()
                i.lockButPress()#Unbind every event's function, but NOT the "on press" function.
            else:
                i.reset()
class DarkCnt(ClickableCnt):
    def __init__(self,master,title="New Settings File",data=[""],cnf={},**kw):
        ClickableCnt.__init__(self,master,kw)
        self.title=title
        self.data=data
        self["height"]="80p"
        self.pack_configure(fill=X,padx="10p",pady="10p",anchor="center")
        self.pack_propagate(0)
        self.lblNew=Label(self,text=title,font="Calibri 20 bold",fg="#cccccc")
        self.lblNew.pack(pady="10p")
        self.reset()
    def on_release(self,event):
        ClickableCnt.on_release(self,event)
class MyEntry(Entry):
    '''
    Entry widget to allow the user to type-in text.
    '''
    def __init__(self,master,cnf={},**kw):
        '''Constructs an entry widget with the parent master.'''
        Entry.__init__(self,master,kw)
        self["width"]=10
        self["bg"]="#404040"
        self["fg"]="white"
        self["font"]="Cambria 13"
        self["relief"]="flat"
        self["bd"]="1p"
        self["highlightbackground"]="#4d4d4d"
        self["highlightcolor"]="#595959"
        self["highlightthickness"]="1p"
        self["insertbackground"]="white"
    def insert1b1(self,index,string):
        '''Allows the 1-by-1 char verification of a muli-char string that can be pasted from the clipboard.'''
        for i in range(len(string)):
            self.insert(i,string[i])
class MyEntryFloat(MyEntry):
    '''
    Entry widget to allow the user to type-in a float number.
    It prevents error by only allowing one dot to be typed-in, no more than one zero to the left and only digits.
    '''
    def __init__(self,master,cnf={},**kw):
        '''Constructs a float number entry widget with the parent master.
        It also declares the function that will allow the verification of the characters or strings that the user tries to type-in
        to prevent undesirable characters or number formats from being submitted.'''
        MyEntry.__init__(self,master,kw)
        def justNum(char,finalStr):
            '''Verification function.'''
            if(len(char)>1):
                '''Verifies if the string to submit has more than one character. If it does, it verifies one at a time.'''
                res=True
                for i in char:
                    res=res&justNum(i,finalStr)
                return res
            zero2Left=False#To know if there is already one zero to the left.
            if (len(finalStr)>=2):#If the the resulting string has more than one character it sets zero2Left as true if the first character is a zero and the next one is a digit.
                if((finalStr[0]=='0')&(finalStr[1].isdigit())):
                    zero2Left=True
            if (len(finalStr)>=3):
                if((finalStr[0]=='-')&(finalStr[1]=='0')&(finalStr[2].isdigit())):
                    zero2Left=True
            dotSpaceAvailable=True#To know if one dot has already been typed-in.
            if (finalStr.count('.')>1):#Checks if there is a dot in the string already and set the availability to False if there is.
                dotSpaceAvailable=False
            auxMinus=True
            if(finalStr.count('-')):
                if((finalStr.count('-')>1)|(finalStr.index('-')!=0)):
                    auxMinus=False
                    return False
            return (~zero2Left&(char.isdigit() | ((char=='.') & dotSpaceAvailable)|(char=='-')))
        self["validate"]="key"#Activate validation when somethin tries to be typed-in
        self["validatecommand"]=(self.register(justNum),'%S','%P')#Associates the defined function to the validation command and
                                                                    #sends the string submitted and the resulting string if the submission is aproved as parameters.
class MyEntryFloatPositive(MyEntry):
    '''
    Entry widget to allow the user to type-in a float number.
    It prevents error by only allowing one dot to be typed-in, no more than one zero to the left and only digits.
    '''
    def __init__(self,master,cnf={},**kw):
        '''Constructs a float number entry widget with the parent master.
        It also declares the function that will allow the verification of the characters or strings that the user tries to type-in
        to prevent undesirable characters or number formats from being submitted.'''
        MyEntry.__init__(self,master,kw)
        def justNum(char,finalStr):
            '''Verification function.'''
            if(len(char)>1):
                '''Verifies if the string to submit has more than one character. If it does, it verifies one at a time.'''
                res=True
                for i in char:
                    res=res&justNum(i,finalStr)
                return res
            zero2Left=False#To know if there is already one zero to the left.
            if (len(finalStr)>=2):#If the the resulting string has more than one character it sets zero2Left as true if the first character is a zero and the next one is a digit.
                if((finalStr[0]=='0')&(finalStr[1].isdigit())):
                    zero2Left=True
            dotSpaceAvailable=True#To know if one dot has already been typed-in.
            if (finalStr.count('.')>1):#Checks if there is a dot in the string already and set the availability to False if there is.
                dotSpaceAvailable=False
            return (~zero2Left&(char.isdigit() | ((char=='.') & dotSpaceAvailable)))
        self["validate"]="key"#Activate validation when somethin tries to be typed-in
        self["validatecommand"]=(self.register(justNum),'%S','%P')#Associates the defined function to the validation command and
                                                                    #sends the string submitted and the resulting string if the submission is aproved as parameters.
class MyEntryInt(MyEntry):
    '''
    Entry widget to allow the user to type-in an integer number.
    It prevents error by only allowing digits.
    '''
    def __init__(self,master,cnf={},**kw):
        '''Constructs an int number entry widget with the parent master.
        It also declares the function that will allow the verification of the characters or strings that the user tries to type-in
        to prevent undesirable characters or number formats from being submitted.'''
        MyEntry.__init__(self,master,kw)
        def justNum(char,finalStr):
            if(len(char)>1):
                res=True
                for i in char:
                    res=res&justNum(i,finalStr)
                return res
            zero2Left=False#To know if there is already one zero to the left.
            if (len(finalStr)>=2):#If the the resulting string has more than one character it sets zero2Left as true if the first character is a zero and the next one is a digit.
                if((finalStr[0]=='0')&(finalStr[1].isdigit())):
                    zero2Left=True
            return (char.isdigit()&(~zero2Left))
        self["validate"]="key"#Activate validation when somethin tries to be typed-in
        self["validatecommand"]=(self.register(justNum),'%S','%P')#Associates the defined function to the validation command and
                                                                    #sends the string submitted and the resulting string if the submission is aproved as parameters.
class MyField(Frame):
    '''
    Widget that shows a label, an entry and a one-choice button group(if iterable is sent).
    The entry widget can be specified to take integers or floats.
    '''
    def __init__(self,master,lblTxt="",entType="int",opt=None,prefix=False,units=False,cnf={},**kw):
        '''
        Constructs a Frame widget that contains a label, an entry widget and a one-choice button group.
        Parameters:
        lblTxt: String variable to show on the label of the widget.
        entType:    ["int","float"]
                    String that specifies if the entry widget should allow only integers or floats too.
        opt: Iterable to create a one-choice button group to the left of the typing area. If None, only the label and the entry will be created.
        prefix: Boolean variable. When True, the getStr function will add the prefix of the units to the result returned.
        units: Boolean variable. When True, the getStr function will add the unit abreviation to the result returned.
        '''
        Frame.__init__(self,master,kw)
        self["height"]="40p"
        self.prefix=prefix
        self.units=units
        self.lblTag=Label(self,text=lblTxt,fg="#cccccc")
        self.lblTag.place(anchor=E,relx=0.5,rely=0.5)
        self.frmInfo=Frame(self)
        #Decides if the entry is for int or float numbers.
        if (entType=="int"):
            self.entInfo=MyEntryInt(self.frmInfo)
        elif (entType=="float"):
            self.entInfo=MyEntryFloat(self.frmInfo)
        elif(entType=="+float"):
            self.entInfo=MyEntryFloatPositive(self.frmInfo)
        self.entInfo.pack(side=LEFT,fill=Y)
        #Generates the button group only if opt is not None.
        if(opt!=None):
            self.cbx=MyComboB(self.frmInfo,opt)
            self.cbx.pack(side=LEFT,fill=BOTH)
        self.frmInfo.place(anchor=W,relx=0.5,rely=0.5)
        self.pack(fill=BOTH,expand=1)

    def setValue(self,value,units=None):
        '''Takes a string and the units to automatically fill in the field and press a specific button if the units a given.'''
        self.entInfo.insert1b1(0,value)
        if(units!=None):
            self.cbx.var.set(units)
            self.cbx.selectElem()
    def getStr(self):
        '''Returns a tuple of the information in the field.'''
        if(self.prefix):
            self.prefix=self.cbx.var.get()[0]
            if(self.units):
                self.units=self.cbx.var.get()[1:]
                return(self.entInfo.get(),self.prefix,self.units)
            return(self.entInfo.get(),self.prefix)
        return (self.entInfo.get(),)

def setLblFont(wd,font):
    '''Sets the font of every label in a widget with the master wd. If wd is a label it also sets the font.
    Parameters:
    wd: Widget.
    font: font string.'''
    if (wd.winfo_class()=="Label"):
        wd["font"]=font
    if (len(wd.winfo_children())!=0):
        for child in wd.winfo_children():
            setLblFont(child,font)
def bgColor(wd=Widget,color=""):
    '''Sets the background color of wd and of every child it has.
    Parameters:
    wd: Widget.
    color: color string.'''
    if ((wd.winfo_class()!="Entry")&(wd.winfo_name()!="!mycombob")):
        wd["background"]=color
        if (len(wd.winfo_children())!=0):
            for child in wd.winfo_children():
                bgColor(child,color)
def fgColor(wd=Widget,color=""):
    '''Sets the foreground color of a label or every child label of wd.
    Parametrs:
    wd: Widget.
    color: color string.'''
    if (wd.winfo_name()!="!mycombob"):
        if (wd.winfo_class()=="Label"):
            wd["fg"]=color
        if (len(wd.winfo_children())!=0):
            for child in wd.winfo_children():
                fgColor(child,color)
def multiBind(wd,event,func,add=0):
    '''Binds a function to and event that happens within wd and every child it has.
    Parametrs:
    wd: Widget.
    event: String specifying the event to bind.
    func: Defined function that gets two parameters. Function to bind to the event.
    add: Boolean variable. If true, it will add the function to the list of funtions that run.'''
    wd.bind(event,func,add)
    if (len(wd.winfo_children())!=0):
        for child in wd.winfo_children():
            multiBind(child,event,func,add)
def multiUnbind(wd,event):
    '''Unbinds every function from the specified event that happens within wd and every child it has.
    Parametrs:
    wd: Widget.
    event: String specifying the event to unbind.'''
    wd.unbind(event)
    if (len(wd.winfo_children())!=0):
        for child in wd.winfo_children():
            multiUnbind(child,event)